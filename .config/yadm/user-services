#!/usr/bin/env bash
# Script to enable and start systemd user services
# To be run AFTER logging into a graphical session (e.g., Hyprland)

# --- Helper Functions ---
print_stage() { echo -e "\n\033[1;36m==> $1\033[0m"; }
print_info() { echo -e "\033[0;34mINFO: $1\033[0m"; }
print_success() { echo -e "\033[0;32mSUCCESS: $1\033[0m"; }
print_warning() { echo -e "\033[0;33mWARNING: $1\033[0m"; }
print_error() { echo -e "\033[0;31mERROR: $1\033[0m"; }

# --- Configuration ---
USER_SERVICES_TO_MANAGE=(
    "pipewire.service"
    "wireplumber.service"
    "udiskie.service"
    "kanshi.service"
    "hyprpolkitagent.service"
    "hyprpaper.service"
    "hypridle.service"
    "gpg-agent.service"
)

# --- Script Body ---
main() {
  print_stage "Systemd User Service Management"

  if [ -z "$DBUS_SESSION_BUS_ADDRESS" ]; then
    print_error "DBUS_SESSION_BUS_ADDRESS is not set!"
    print_error "This script must be run from within an active user session (e.g., after logging into Hyprland)."
    exit 1
  else
    print_info "DBUS_SESSION_BUS_ADDRESS found: $DBUS_SESSION_BUS_ADDRESS"
  fi

  if [ -z "$XDG_RUNTIME_DIR" ]; then
    print_warning "XDG_RUNTIME_DIR is not set. Some services might have issues."
    # Some basic user services might still work, but it's not ideal.
  else
    print_info "XDG_RUNTIME_DIR found: $XDG_RUNTIME_DIR"
  fi

  if [ ${#USER_SERVICES_TO_MANAGE[@]} -eq 0 ]; then
    print_warning "No user services defined in USER_SERVICES_TO_MANAGE array. Nothing to do."
    exit 0
  fi

  print_info "The following user services/sockets will be processed: ${USER_SERVICES_TO_MANAGE[*]}"

  for service_spec in "${USER_SERVICES_TO_MANAGE[@]}"; do
    service_name_base=$(echo "$service_spec" | sed 's/\.\(service\|socket\)$//')

    print_info "Processing: $service_spec"

    # Check if the unit file exists
    if ! systemctl --user list-unit-files --all | grep -q "^${service_spec}"; then
      print_warning "Unit file $service_spec not found. Skipping."
      continue
    fi

    # Enable the service (creates symlinks) and start it immediately if it's not already active
    # `enable --now` is a convenient way to do both.
    # It first enables, then tries to start.
    if systemctl --user is-active --quiet "$service_spec"; then
        print_success "$service_spec is already active."
        # Even if active, ensure it's enabled for future logins
        if ! systemctl --user is-enabled --quiet "$service_spec"; then
            print_info "Attempting to enable (already active) $service_spec..."
            if systemctl --user enable "$service_spec"; then
                print_success "$service_spec enabled successfully."
            else
                print_error "Failed to enable (already active) $service_spec."
            fi
        else
            print_info "$service_spec is already enabled."
        fi
    else
        print_info "Attempting to enable and immediately start $service_spec..."
        if systemctl --user enable --now "$service_spec"; then
            # Give it a brief moment, then check status
            sleep 1
            if systemctl --user is-active --quiet "$service_spec"; then
                print_success "$service_spec enabled and started successfully."
            else
                print_warning "$service_spec was enabled, but is not reported as active. It might have exited or failed to start."
                print_warning "Check its status with: systemctl --user status $service_spec"
                print_warning "And logs with: journalctl --user -u $service_spec -e"
            fi
        else
            print_error "Failed to enable and/or start $service_spec."
            print_warning "Check its status with: systemctl --user status $service_spec"
            print_warning "And logs with: journalctl --user -u $service_spec -e"
        fi
    fi
    echo # Newline for readability
  done

  print_stage "User service management finished."
  print_info "You can check the status of services manually using 'systemctl --user status <service_name>'."
}

# Run main
main
