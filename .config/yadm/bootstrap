#!/usr/bin/env bash
# yadm bootstrap script for Arch Linux Hyprland Workstation

# --- Helper Functions ---
print_stage() { echo -e "\n\033[1;36m==> $1\033[0m"; }
print_info() { echo -e "\033[0;34mINFO: $1\033[0m"; }
print_success() { echo -e "\033[0;32mSUCCESS: $1\033[0m"; }
print_warning() { echo -e "\033[0;33mWARNING: $1\033[0m"; }
print_error() { echo -e "\033[0;31mERROR: $1\033[0m"; }

command_exists() { command -v "$1" >/dev/null 2>&1; }
package_installed() { pacman -Q "$1" &>/dev/null; }

ensure_sudo() {
  if [[ $EUID -ne 0 ]]; then
    sudo -v
    while true; do
      sudo -n true
      sleep 60
      kill -0 "$$" || exit
    done 2>/dev/null &
    SUDO_KEEPALIVE_PID=$!
    trap 'kill "$SUDO_KEEPALIVE_PID" 2>/dev/null' EXIT
  fi
}

# --- Pre-flight Checks ---
check_prerequisites() {
    print_stage "Running Pre-flight Checks..."
    
    # Check internet connectivity
    if ! ping -c 1 archlinux.org &>/dev/null; then
        print_error "No internet connection detected."
        exit 1
    fi
    
    # Check if running as root (shouldn't be)
    if [[ $EUID -eq 0 ]]; then
        print_error "This script should not be run as root."
        exit 1
    fi
    
    print_success "Pre-flight checks passed."
}

# --- GPU Detection ---
detect_gpu() {
    print_stage "Detecting GPU and adding appropriate drivers..."
    
    local gpu_packages=()
    
    # Check for NVIDIA GPU
    if lspci | grep -i nvidia &>/dev/null; then
        print_info "NVIDIA GPU detected."
        gpu_packages+=(
            "nvidia" "nvidia-utils" "lib32-nvidia-utils"
            "nvidia-settings" "libva-nvidia-driver"
        )
    fi
    
    # Check for AMD GPU
    if lspci | grep -i "vga.*amd\|vga.*ati\|vga.*radeon" &>/dev/null; then
        print_info "AMD GPU detected."
        gpu_packages+=(
            "mesa" "lib32-mesa" "vulkan-radeon" "lib32-vulkan-radeon"
            "libva-mesa-driver" "lib32-libva-mesa-driver"
            "mesa-vdpau" "lib32-mesa-vdpau"
        )
    fi
    
    # Check for Intel integrated graphics
    if lspci | grep -i "vga.*intel" &>/dev/null; then
        print_info "Intel integrated GPU detected."
        gpu_packages+=(
            "mesa" "lib32-mesa" "vulkan-intel" "lib32-vulkan-intel"
            "intel-media-driver" "libva-intel-driver" "libva-utils"
        )
    fi
    
    # Add detected GPU packages to base packages
    if [[ ${#gpu_packages[@]} -gt 0 ]]; then
        PACKAGE_GROUPS[gpu]="${gpu_packages[*]}"
        print_success "Added GPU-specific packages: ${gpu_packages[*]}"
    else
        print_warning "No specific GPU detected. Only basic mesa drivers will be installed."
        PACKAGE_GROUPS[gpu]="mesa vulkan-mesa-drivers"
    fi
}

# --- Configuration ---
AUR_HELPER_CMD="yay"
PYTHON_USER_BIN_DIR="$HOME/.local/bin"
MPV_CONFIG_DIR="$HOME/.config/mpv"
export PATH="$PYTHON_USER_BIN_DIR:$HOME/.cargo/bin:$PATH"

# Package groups organized by function
declare -A PACKAGE_GROUPS=(
    [base]="linux linux-zen fwupd grub intel-ucode"
    [hyprland]="hyprland wayland wayland-protocols sddm polkit hyprpolkitagent"
    [desktop_portal]="xdg-desktop-portal-hyprland xdg-desktop-portal-gtk"
    [build_tools]="base-devel git"
    [terminal]="foot tmux zsh zsh-completions zsh-syntax-highlighting zsh-autosuggestions starship"
    [network]="networkmanager network-manager-applet gnome-keyring"
    [bluetooth]="bluez bluez-utils blueman"
    [system_utils]="brightnessctl udiskie bat eza fd ripgrep fzf vivid whois btop fastfetch"
    [archive_utils]="curl wget unzip zip tar unrar rsync p7zip ark"
    [hypr_extras]="hyprpaper hyprlock hyprpicker hypridle swaync waybar"
    [theming]="nwg-look kvantum qt5ct qt6ct"
    [fonts]="ttf-liberation ttf-dejavu noto-fonts noto-fonts-emoji noto-fonts-cjk ttf-jetbrains-mono ttf-jetbrains-mono-nerd"
    [screenshot]="grim slurp satty wl-clipboard cliphist"
    [audio]="pipewire wireplumber pipewire-audio pipewire-pulse pipewire-alsa pipewire-jack lib32-pipewire pavucontrol pamixer playerctl easyeffects qpwgraph cava"
    [file_managers]="dolphin yazi ffmpegthumbnailer ffmpeg poppler imagemagick"
    [productivity]="libreoffice-fresh obsidian"
    [development]="neovim github-cli nodejs npm python go jdk-openjdk"
    [media]="mpv obs-studio"
    [system_tools]="gparted wlr-randr kanshi uwsm"
    [security]="ufw gufw gnupg"
)

AUR_PACKAGES=(
    "yay"
    "waybar-update"
    "rofi-wayland" "rofi-emoji"
    "catppuccin-cursors-mocha"
    "hyprshot"
    "pyprland"
    "ueberzugpp"
    "resvg"
    "zen-browser-bin"
    "vesktop-bin"
    "visual-studio-code-bin"
    "lazygit" "git-delta"
    "swayosd-git"
    "qimgv-git"
    "topgrade"
)

# --- Service Management ---
manage_services() {
    print_stage "Enabling System Services..."
    
    local services=(
        "sddm.service"
        "NetworkManager.service"
        "bluetooth.service"
        "ufw.service"
    )
    
    for service in "${services[@]}"; do
        local service_name=${service%.*}
        
        # Check if service exists
        if ! systemctl list-unit-files "$service" &>/dev/null; then
            print_warning "Service $service not found, skipping."
            continue
        fi
        
        # Enable service
        if ! systemctl is-enabled "$service" &>/dev/null; then
            print_info "Enabling $service..."
            if ! sudo systemctl enable "$service"; then
                print_warning "Failed to enable $service"
                continue
            fi
        else
            print_success "Service $service already enabled."
        fi
        
        # Start service
        if ! systemctl is-active "$service" &>/dev/null; then
            print_info "Starting $service..."
            sudo systemctl start "$service" || print_warning "Failed to start $service (might start on reboot)"
        else
            print_success "Service $service already running."
        fi
    done
}

# --- Rust Installation ---
install_rust() {
    print_stage "Installing Rust toolchain..."
    
    if command_exists rustc && command_exists cargo; then
        print_success "Rust already installed."
        return 0
    fi
    
    # Install rustup if needed
    if ! command_exists rustup; then
        print_info "Installing rustup..."
        if ! curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --no-modify-path --default-toolchain stable; then
            print_error "Rustup installation failed."
            exit 1
        fi
    fi
    
    # Source cargo env
    if [[ -f "$HOME/.cargo/env" ]]; then
        source "$HOME/.cargo/env"
    else
        print_warning "Cargo env file not found after rustup install."
    fi
    
    # Verify installation
    if ! command_exists rustc || ! command_exists cargo; then
        print_error "Rust installation verification failed."
        exit 1
    fi
    
    print_success "Rust toolchain installed successfully."
}

# --- Mirror Optimization ---
optimize_mirrors() {
    print_stage "Optimizing Pacman Mirrors..."
    
    # Install reflector if not present
    if ! package_installed "reflector"; then
        print_info "Installing reflector for mirror optimization..."
        if ! sudo pacman -S --needed --noconfirm reflector; then
            print_warning "Failed to install reflector. Skipping mirror optimization."
            return 1
        fi
    fi
    
    print_info "Backing up current mirrorlist..."
    sudo cp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backup
    
    print_info "Updating mirrorlist with fastest mirrors..."
    if ! sudo reflector --country Germany,Netherlands,France --protocol https --latest 20 --sort rate --save /etc/pacman.d/mirrorlist; then
        print_warning "Reflector failed. Restoring backup mirrorlist."
        sudo cp /etc/pacman.d/mirrorlist.backup /etc/pacman.d/mirrorlist
        return 1
    fi
    
    print_success "Mirrorlist optimized successfully."
}

# --- Script Body ---
main() {
    check_prerequisites
    ensure_sudo
    mkdir -p "$PYTHON_USER_BIN_DIR" "$MPV_CONFIG_DIR"

    # Optimize mirrors first
    optimize_mirrors

    # Detect GPU and add appropriate packages
    detect_gpu

    # Ensure multilib repository is enabled
    print_stage "Checking and Enabling Multilib Repository..."
    if grep -q "^#\[multilib\]" /etc/pacman.conf; then
        print_info "Multilib repository is commented out. Enabling..."
        sudo sed -i '/^#\[multilib\]/{N;s/#\[multilib\]\n#Include/\[multilib\]\nInclude/}' /etc/pacman.conf
        print_info "Multilib enabled. Database will be synced in the next step."
    elif ! grep -q "^\[multilib\]" /etc/pacman.conf; then
        print_warning "Multilib section not found in /etc/pacman.conf in a recognizable format."
        print_warning "Please ensure it's properly configured manually if lib32 packages are needed."
    else
        print_success "Multilib repository is already enabled."
    fi

    # Pre-Pacman System Check & Update
    print_stage "Preparing Pacman and Performing System Update..."
    if [ -f "/var/lib/pacman/db.lck" ]; then
        print_warning "/var/lib/pacman/db.lck found!"
        print_warning "This means another pacman instance may be running or was interrupted."
        print_warning "If you are sure no other pacman instance is running, you can try removing it with 'sudo rm /var/lib/pacman/db.lck' and re-run the script."
        print_error "Exiting due to existing pacman lock."
        exit 1
    fi

    print_info "Attempting to synchronize package databases and update the entire system first..."
    if ! sudo pacman -Syu --noconfirm; then
        print_error "Critical: Failed to synchronize databases and update system (pacman -Syu)."
        print_error "Please check your internet connection, your mirrorlist (/etc/pacman.d/mirrorlist), and try running 'sudo pacman -Syu' manually in your terminal to see the exact errors."
        print_error "You might need to update your mirrorlist, for example, using the 'reflector' tool."
        exit 1
    else
        print_success "System synchronized and updated successfully."
    fi

    # Install Pacman Packages by groups
    print_stage "Installing Pacman packages by groups..."
    local all_pacman_packages=()
    
    # Collect all packages from groups
    for group in "${!PACKAGE_GROUPS[@]}"; do
        print_info "Processing group: $group"
        read -ra group_packages <<< "${PACKAGE_GROUPS[$group]}"
        all_pacman_packages+=("${group_packages[@]}")
    done
    
    local missing_pacman_pkgs=()
    for pkg in "${all_pacman_packages[@]}"; do
        if ! package_installed "$pkg"; then
            missing_pacman_pkgs+=("$pkg")
        else
            print_info "Pacman: $pkg already installed."
        fi
    done
    
    if [ ${#missing_pacman_pkgs[@]} -gt 0 ]; then
        if ! sudo pacman -S --needed --noconfirm "${missing_pacman_pkgs[@]}"; then
            print_error "Pacman installation of one or more specified packages failed."
            print_error "Try installing them manually to see the specific error, e.g., 'sudo pacman -S package_name'."
            exit 1
        fi
    else
        print_success "All specified Pacman packages are already installed and up-to-date."
    fi

    # Install Rust
    install_rust

    # Install yay (AUR Helper)
    print_stage "Installing AUR Helper (yay)..."
    if ! command_exists $AUR_HELPER_CMD; then
        print_info "$AUR_HELPER_CMD not found. Installing..."
        if ! package_installed "git" || ! package_installed "base-devel"; then
            print_info "Installing git and base-devel for yay compilation..."
            if ! sudo pacman -S --needed --noconfirm git base-devel; then
                print_error "Failed to install git/base-devel."
                exit 1
            fi
        fi
        (
            cd /tmp || {
                print_error "Failed to cd to /tmp"
                exit 1
            }
            if [ -d "yay" ]; then rm -rf yay; fi
            if ! git clone https://aur.archlinux.org/yay.git; then
                print_error "Failed to clone yay repository"
                exit 1
            fi
            cd yay || {
                print_error "Failed to cd to yay directory"
                exit 1
            }
            if ! makepkg -si --noconfirm --needed; then
                print_error "Failed to build yay"
                exit 1
            fi
        )
        if ! command_exists $AUR_HELPER_CMD; then
            print_error "$AUR_HELPER_CMD installation failed."
            exit 1
        fi
        print_success "$AUR_HELPER_CMD installed successfully."
    else
        print_success "$AUR_HELPER_CMD is already installed."
    fi

    # Install AUR Packages (excluding yay itself)
    print_stage "Installing AUR packages..."
    local missing_aur_pkgs_to_install=()
    for pkg in "${AUR_PACKAGES[@]}"; do
        if [[ "$pkg" == "yay" ]]; then continue; fi
        if [[ -n "$pkg" ]]; then
            if ! package_installed "$pkg"; then
                missing_aur_pkgs_to_install+=("$pkg")
            else
                print_info "AUR: $pkg already installed."
            fi
        fi
    done
    if [ ${#missing_aur_pkgs_to_install[@]} -gt 0 ]; then
        if ! $AUR_HELPER_CMD -S --needed --noconfirm "${missing_aur_pkgs_to_install[@]}"; then
            print_error "AUR installation failed."
            exit 1
        fi
    else
        print_success "All specified AUR packages (excluding yay) are already installed."
    fi

    # Custom Installations
    print_stage "Handling Custom Installations..."

    # uv (Python package manager via curl)
    print_info "Installing/Updating uv..."
    if ! command_exists uv; then
        if ! curl -LsSf https://astral.sh/uv/install.sh | sh; then
            print_error "uv installation failed."
            exit 1
        fi

	# Source cargo env to make uv available immediately
	if [[ -f "$HOME/.cargo/env" ]]; then
	    source "$HOME/.cargo/env"
	fi

        # Re-check after install attempt
        if ! command_exists uv && [ -x "$PYTHON_USER_BIN_DIR/uv" ]; then
            print_success "uv installed to $PYTHON_USER_BIN_DIR."
        elif command_exists uv; then
            print_success "uv installed (found in PATH)."
        else
            print_warning "uv installation attempted, but 'uv' command might not be in current PATH immediately. It should be available in new shells."
        fi
    else
        print_success "uv already installed."
    fi

    # commitizen (via uv)
    print_info "Installing/Updating commitizen with uv..."
    UV_CMD_PATH=""
    if command_exists uv; then
        UV_CMD_PATH="uv"
    elif [ -x "$PYTHON_USER_BIN_DIR/uv" ]; then 
        UV_CMD_PATH="$PYTHON_USER_BIN_DIR/uv"
    fi

    if [ -n "$UV_CMD_PATH" ]; then
        if ! ("$UV_CMD_PATH" tool list 2>/dev/null | grep -q "commitizen") && ! command_exists cz; then
            print_info "Attempting to install commitizen tool via uv..."
            if ! "$UV_CMD_PATH" tool install commitizen; then
                print_error "commitizen installation via uv tool failed."
                exit 1
            fi
            if ! ("$UV_CMD_PATH" tool list 2>/dev/null | grep -q "commitizen") && ! command_exists cz; then
                print_warning "commitizen (cz) tool not found after uv install. Check uv setup and PATH."
            else
                print_success "commitizen (cz) installed via uv tool."
            fi
        else
            print_success "commitizen (cz) already available (possibly via uv tool or PATH)."
        fi
    else
        print_warning "uv not found. Skipping commitizen installation."
    fi

    # uosc (mpv script)
    print_info "Installing/Updating uosc for mpv..."
    if [ ! -f "$MPV_CONFIG_DIR/scripts/uosc.lua" ]; then
        mkdir -p "$MPV_CONFIG_DIR/scripts"
        print_info "Running uosc unix installer script..."
        if ! /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/tomasklaen/uosc/HEAD/installers/unix.sh)"; then
            print_error "uosc installation script failed."
            exit 1
        fi
        if [ -f "$MPV_CONFIG_DIR/scripts/uosc.lua" ]; then
            print_success "uosc installed successfully."
        else
            print_warning "uosc installation script ran, but uosc.lua not found in expected location. Check manually."
        fi
    else
        print_success "uosc.lua already present. Skipping uosc installation."
    fi

    # Enable and start services
    manage_services

    # Final Steps & Info
    print_stage "Finalizing Setup..."
    print_info "Updating font cache..."
    if ! fc-cache -f -v; then
        print_warning "fc-cache failed."
    fi

    if [[ "$(basename "$SHELL")" != "zsh" ]]; then
        print_warning "To set Zsh as your default shell, please run: chsh -s $(which zsh)"
        print_warning "You will be prompted for your password. A logout/login is required for the change to take effect."
    else
        print_success "Zsh is already the default shell."
    fi

    print_info "To check for and apply firmware updates (recommended after a fresh install and periodically):"
    print_info "1. sudo fwupdmgr refresh --force"
    print_info "2. sudo fwupdmgr get-updates"
    print_info "3. sudo fwupdmgr update (this may be interactive and require reboots)"

    print_stage "Bootstrap script finished!"
    print_warning "A reboot might be necessary for all changes to take full effect (kernel, services, audio fix, shell)."
}

main
